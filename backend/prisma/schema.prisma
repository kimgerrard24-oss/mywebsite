generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                        String   @id @default(uuid())
  email                     String   @unique
  name                      String?
  displayName               String?
  username                  String   @unique
  hashedPassword            String?
  isEmailVerified           Boolean  @default(false)
    // ===== Identity / Compliance =====
  countryCode               String?  @db.Char(2) // "TH", "US", "JP"
  dateOfBirth               DateTime?

  phoneNumber               String?  @unique
  isPhoneVerified           Boolean  @default(false)

  // ===== Account Security =====
  isAccountLocked           Boolean  @default(false)
  accountLockedAt           DateTime?
  accountLockReason         String?
  isDisabled                Boolean  @default(false)
  active                    Boolean  @default(true)
  lastLoginAt               DateTime?
  provider                  String?
  providerId                String?
  disabledReason            String?
  disabledAt                DateTime?
  bio                       String?
  firebaseUid               String?  @unique
  avatarUrl                 String?
  coverUrl                  String?
  currentRefreshTokenHash   String?
  adminNote                 String?
  lastSeenAt                DateTime?
  role                      UserRole @default(USER)
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  isBanned          Boolean   @default(false)
  bannedAt          DateTime?
  banReason         String?
  bannedByAdminId   String?
  appeals Appeal[]
  resolvedAppeals Appeal[] @relation("AppealResolvedByAdmin")
  reports Report[] @relation("UserReports")
  resolvedReports Report[] @relation("ReportResolvedBy")
  // relation (optional แต่ production-grade)
  bannedByAdmin     User?     @relation("UserBannedByAdmin",fields: [bannedByAdminId],references: [id],onDelete: SetNull)
  moderationActions ModerationAction[] @relation("AdminModerationActions")
  // ใน User model (admin side)
  bannedUsers User[] @relation("UserBannedByAdmin")

  identityVerificationTokens IdentityVerificationToken[]
  securityEvents             SecurityEvent[]
  identityHistory            UserIdentityHistory[]

  // ===== Audit =====
  auditLogs AuditLog[]
  adminActionLogs AdminActionLog[]

  // ===== Comments =====
  comments        Comment[] @relation("CommentAuthor")  
  deletedComments Comment[] @relation("CommentDeletedBy")

  commentLikes CommentLike[]
  mentionedInComments CommentMention[]

  // ===== Posts =====
  posts        Post[] @relation("PostAuthor")
  deletedPosts Post[] @relation("PostDeletedBy")
  likedPosts   PostLike[]

  // ===== Media / OAuth =====
  media               Media[]
  oauthAccounts       OAuthAccount[]

  // ===== Auth / Session =====
  refreshTokens RefreshToken[]
  sessions      Session[]

  // ===== Activity / Notification =====
  activities          UserActivity[]
  notifications       Notification[]
  actedNotifications  Notification[] @relation("NotificationActor")

  // ===== Social =====
  following Follow[] @relation("UserFollowing")
  followers Follow[] @relation("UserFollowers")

  // ===== Chat =====
  chatReports        ChatReport[]
  chatParticipants   ChatParticipant[]
  sentChatMessages   ChatMessage[] @relation("ChatMessageSender")
  chatReadStates     ChatReadState[]
  chatMessageReports ChatMessageReport[]
  chatTypingStates   ChatTypingState[]

  // ===== Blocking =====
  blockedUsers UserBlock[] @relation("UserBlocker")
  blockedBy    UserBlock[] @relation("UserBlocked")

  @@unique([provider, providerId])
  @@index([isBanned, bannedAt])
  @@index([phoneNumber])
  @@index([isAccountLocked, accountLockedAt])
}

enum UserRole {
  USER
  ADMIN
}

enum DeleteSource {
  USER     // user ลบเอง
  ADMIN    // admin moderation
  SYSTEM   // automation / policy
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  ipAddress    String?
  revokedAt    DateTime?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserActivity {
  id        String   @id @default(uuid())
  userId    String
  action    String
  detail    String?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model OAuthAccount {
  id           String    @id @default(uuid())
  userId       String
  provider     String
  providerId   String
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([provider, providerId])
  @@unique([provider, providerId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  revoked   Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?
  email      String?
  action     String
  success    Boolean
  reason     String?
  targetId   String?
  ip         String?
  userAgent  String?
  metadata   Json?
  occurredAt DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])
}

model Post {
  id            String         @id @default(uuid())

  authorId      String
  deletedById   String?

  content       String
  isPublished   Boolean        @default(true)
  publishedAt   DateTime       @default(now())
  isEdited      Boolean        @default(false)
  editedAt      DateTime?
  isDeleted     Boolean        @default(false)
  deletedAt     DateTime?
  isHidden      Boolean        @default(false)
  hiddenAt      DateTime?
  hiddenByAdminId String?
  hiddenReason    String?

  deletedSource DeleteSource?
  deleteReason  String?

  author User @relation("PostAuthor",fields: [authorId],references: [id])

  deletedBy User? @relation("PostDeletedBy",fields: [deletedById],references: [id],onDelete: SetNull)

  commentCount Int @default(0)
  likeCount    Int @default(0)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  visibility  PostVisibility @default(PUBLIC)

  comments Comment[]
  media    PostMedia[]
  tags     PostTag[]
  likes    PostLike[]

  @@index([authorId, publishedAt])
  @@index([isPublished, isDeleted, isHidden, publishedAt])
  @@index([isDeleted, deletedAt])
  @@index([deletedSource, deletedAt])
  @@index([deletedById, deletedAt])
}

model PostLike {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([postId, userId]) 
  @@index([postId])
  @@index([userId])
}

model PostMedia {
  id        String   @id @default(uuid())
  postId    String
  mediaId   String
  createdAt DateTime @default(now())
  media     Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([postId, mediaId])
  @@index([postId])
  @@index([mediaId])
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
}

model Media {
  id          String      @id @default(uuid())

  ownerUserId String
  owner       User        @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)

  objectKey   String      @unique
  mediaType   MediaType
  mimeType    String

  width       Int?
  height      Int?
  duration    Int?

  createdAt   DateTime    @default(now())

  deletedAt   DateTime?   // เมื่อ user ลบ post / media
  cleanupAt   DateTime?   // เวลาที่ cron จะลบจาก R2
  cleanupFailCount Int        @default(0)
  lastCleanupError String?
  posts       PostMedia[]
  chatMessageMedia ChatMessageMedia[]
  @@index([ownerUserId])
  @@index([mediaType])
  @@index([deletedAt])
  @@index([cleanupAt])
}

model Comment {
  id        String   @id @default(uuid())

  postId    String
  authorId  String
  parentId  String?

  content   String
  isHidden          Boolean   @default(false)
  hiddenAt          DateTime?
  isEdited  Boolean  @default(false)
  editedAt  DateTime?
  hiddenByAdminId String?
  hiddenReason    String?

  isDeleted Boolean  @default(false)
  deletedAt DateTime?

  deletedById   String?
  deletedSource DeleteSource?
  deleteReason  String?

  tags CommentTag[]

  author User @relation("CommentAuthor",fields: [authorId],references: [id])

  deletedBy User? @relation("CommentDeletedBy",fields: [deletedById],references: [id],onDelete: SetNull)

  parent Comment? @relation("CommentReplies",fields: [parentId],references: [id],onDelete: Cascade)

  replies Comment[] @relation("CommentReplies")

  post Post @relation(fields: [postId],references: [id],onDelete: Cascade)
  
  mentions CommentMention[] 
  likes CommentLike[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([parentId, createdAt])
  @@index([authorId])
  @@index([isDeleted, parentId])
  @@index([isDeleted, deletedAt])
  @@index([deletedSource, deletedAt])
  @@index([deletedById, deletedAt])
}

model CommentLike {
  id        String   @id @default(uuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())

  // relations
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([commentId, userId]) // 1 user like ต่อ 1 comment
  @@index([commentId])
  @@index([userId])
}

model CommentTag {
  commentId String
  tagId     String

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([commentId, tagId])
  @@index([tagId])
}

model CommentMention {
  id        String   @id @default(uuid())

  commentId String
  userId    String

  createdAt DateTime @default(now())

  // relations
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // prevent duplicate mention
  @@unique([commentId, userId])

  // query optimization
  @@index([commentId])
  @@index([userId])
}

model Tag {
  id        String    @id @default(uuid())
  name      String    @unique
  createdAt DateTime  @default(now())
  postCount Int      @default(0)
  posts     PostTag[]
  comments  CommentTag[]
  @@index([name])
}

model PostTag {
  postId String
  tagId  String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([tagId])
}

enum PostVisibility {
  PUBLIC
  PRIVATE
}

model Follow {
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  /// User who performs the follow action
  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)

  /// User who is being followed
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  /// Composite primary key (prevent duplicate follow)
  @@id([followerId, followingId])

  /// GET /followers/:userId (ORDER BY createdAt DESC)
  @@index([followingId, createdAt])

  /// GET /following/:userId (ORDER BY createdAt DESC)
  @@index([followerId, createdAt])
}

model Notification {
  id            String   @id @default(uuid())

  /// เจ้าของ notification (คนที่ได้รับ)
  userId        String

  /// ประเภท notification (LIKE_POST, COMMENT_POST, FOLLOW, SYSTEM, etc.)
  type          String

  /// คนที่เป็นต้นเหตุ (nullable เช่น SYSTEM)
  actorUserId  String?

  /// entity หลักที่เกี่ยวข้อง (postId, commentId, etc.)
  entityId      String?

  payload   Json?

  /// สถานะการอ่าน
  isRead        Boolean  @default(false)
  readAt        DateTime?

  /// เวลาเกิด notification
  createdAt     DateTime @default(now())

  /// relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  actor         User?    @relation("NotificationActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  /// =========================
  /// Indexes (สำคัญมาก)
  /// =========================

  /// GET /notifications (ORDER BY createdAt DESC)
  @@index([userId, createdAt])

  /// unread badge / read-all
  @@index([userId, isRead])

  /// audit / debug / analytics
  @@index([type])
}

model Chat {
  id        String   @id @default(uuid())
  isGroup   Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  participants ChatParticipant[]
  messages     ChatMessage[]
  readStates   ChatReadState[]
  typingStates ChatTypingState[]
  reports      ChatReport[]
  @@index([isGroup])
  @@index([updatedAt])
}

model ChatParticipant {
  chatId  String
  userId  String

  joinedAt DateTime @default(now())
  leftAt   DateTime?

  // relations
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([chatId, userId])
  @@index([userId])
  @@index([chatId])
}

model ChatMessage {
  id        String   @id @default(uuid())
  chatId   String
  senderId String

  content  String?

  // message state
  isEdited  Boolean   @default(false)
  editedAt  DateTime?
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())

  // relations
  chat   Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  reports ChatMessageReport[]
  
  media ChatMessageMedia[]

  @@index([chatId, createdAt])
  @@index([senderId])
}

model ChatMessageMedia {
  id        String   @id @default(uuid())
  messageId String
  mediaId   String
  createdAt DateTime @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  media   Media       @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([mediaId])
}

model ChatReadState {
  chatId String
  userId String
  lastReadMessageId  String?
  lastReadAt DateTime?
  updatedAt  DateTime @updatedAt
  
  // relations
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([chatId, userId])
  @@index([userId])
  @@index([chatId, lastReadAt])
}

model ChatMessageReport {
  id        String   @id @default(uuid())
  messageId String
  reporterId String

  reason    String
  detail    String?

  createdAt DateTime @default(now())

  // relations
  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  reporter User        @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([reporterId])
}

model ChatTypingState {
  chatId String
  userId String

  isTyping Boolean @default(false)
  updatedAt DateTime @updatedAt

  // relations
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([chatId, userId])
}

model UserBlock {
  blockerId String
  blockedId String

  createdAt DateTime @default(now())

  /// relations
  blocker User @relation("UserBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlocked", fields: [blockedId], references: [id], onDelete: Cascade)

  /// prevent duplicate block
  @@id([blockerId, blockedId])

  /// check who blocked me
  @@index([blockedId])

  /// check who I blocked
  @@index([blockerId])
}

enum ChatReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  SCAM
  SEXUAL_CONTENT
  OTHER
}

model ChatReport {
  id         String   @id @default(uuid())
  chatId     String
  reporterId String

  reason ChatReportReason
  createdAt DateTime @default(now())
  description String?
  // relations
  chat     Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  reporter User @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  // prevent duplicate report per user per chat
  @@unique([chatId, reporterId])

  @@index([chatId])
  @@index([reporterId])
  @@index([createdAt])
}

model AdminActionLog {
  id        String   @id @default(uuid())
  adminId  String
  action   String
  targetId String?
  detail   Json?
  ip       String?
  reportId String?
  appealId String?
  appeal   Appeal? @relation(fields: [appealId], references: [id], onDelete: SetNull)
  report   Report? @relation("ReportActionLogs",fields: [reportId],references: [id],onDelete: SetNull)
  createdAt DateTime @default(now())
  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId, createdAt])
  @@index([action])
  @@index([reportId])
  @@index([appealId])
}

model Report {
  id            String   @id @default(uuid())

  reporterId    String
  targetType    ReportTargetType
  targetId      String
  
  reason        ReportReason
  description   String?
  appeals       Appeal[]
  status        ReportStatus @default(PENDING)
  withdrawnAt DateTime?

  resolvedByAdminId String?
  resolvedAt    DateTime?
  resolutionNote String?
  adminActionLogs AdminActionLog[] @relation("ReportActionLogs")
  createdAt     DateTime @default(now())
  reporter User @relation("UserReports", fields: [reporterId], references: [id], onDelete: Cascade)
  resolvedByAdmin User? @relation("ReportResolvedBy", fields: [resolvedByAdminId], references: [id], onDelete: SetNull)
 
  @@index([targetType, targetId])
  @@index([status, createdAt])
  @@index([reporterId])
  @@index([status, withdrawnAt])
  @@index([reporterId, status])
  @@unique([reporterId, targetType, targetId])
}

model ModerationAction {
  id         String @id @default(uuid())
  adminId    String
  actionType ModerationActionType
  targetType ModerationTargetType
  targetId   String
  reason     String
  appeals    Appeal[]
  createdAt  DateTime @default(now())

  admin User @relation("AdminModerationActions", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([targetType, targetId])
}

enum ReportStatus {
  PENDING
  REVIEWED
  ACTION_TAKEN
  REJECTED
  WITHDRAWN
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  SCAM
  NSFW
  MISINFORMATION
  OTHER
}

enum ReportTargetType {
  POST
  COMMENT
  USER
  CHAT_MESSAGE
}

enum ModerationTargetType {
  USER
  POST
  COMMENT
  CHAT_MESSAGE
}

enum ModerationActionType {
  HIDE
  UNHIDE
  DELETE
  BAN_USER
  WARN
  NO_ACTION
}

model Appeal {
  id        String   @id @default(uuid())

  /// ===== Owner =====
  userId    String

  /// ===== Target being appealed =====
  targetType AppealTargetType
  targetId   String

  /// reference to moderation / report (optional but important for audit)
  moderationActionId String?
  reportId           String?

  /// ===== Appeal content =====
  reason     String
  detail     String?

  /// ===== Status =====
  status     AppealStatus @default(PENDING)

  withdrawnAt DateTime?

  /// ===== Admin resolution =====
  resolvedByAdminId String?
  resolvedAt        DateTime?
  resolutionNote    String?

  /// ===== Timestamps =====
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// ===== Relations =====
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  resolvedByAdmin User? @relation("AppealResolvedByAdmin",fields: [resolvedByAdminId],references: [id],onDelete: SetNull)

  moderationAction ModerationAction? @relation(fields: [moderationActionId],references: [id],onDelete: SetNull)

  report Report? @relation(fields: [reportId], references: [id], onDelete: SetNull)

  adminActionLogs AdminActionLog[]

  /// ===== Constraints =====

  /// 1 target มี appeal active ได้ครั้งเดียวต่อ user
  @@unique([userId, moderationActionId])

  /// ===== Indexes =====
  @@index([userId, createdAt])                // GET /appeals/me
  @@index([status, createdAt])                // admin queue
  @@index([targetType, targetId])
  @@index([resolvedByAdminId, resolvedAt])
}

enum AppealStatus {
  PENDING     // user ส่ง appeal แล้ว รอ admin
  APPROVED    // admin เห็นด้วย → rollback moderation
  REJECTED    // admin ปฏิเสธ
  WITHDRAWN   // user ถอน appeal
}

enum AppealTargetType {
  POST
  COMMENT
  USER
  CHAT_MESSAGE
}

enum VerificationType {
  EMAIL_VERIFY 
  EMAIL_CHANGE
  PHONE_CHANGE
  ACCOUNT_LOCK
  PASSWORD_RESET
  SENSITIVE_ACTION   // เช่น profile export, username change (ถ้าอยากใช้ token-based)
}

enum SecurityEventType {
  LOGIN_SUCCESS
  LOGIN_FAILED
  PASSWORD_CHANGED
  EMAIL_CHANGE_REQUEST
  EMAIL_CHANGED
  PHONE_CHANGE_REQUEST
  PHONE_CHANGED
  USERNAME_CHANGED
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED
  SESSION_REVOKED
  SUSPICIOUS_ACTIVITY
  CREDENTIAL_VERIFIED
  PROFILE_EXPORTED
  EMAIL_VERIFIED
}

model IdentityVerificationToken {
  id        String           @id @default(uuid())

  userId    String
  type      VerificationType

  /// hash ของ token เท่านั้น (เช่น sha256)
  tokenHash String

  /// email หรือ phone ใหม่ (กรณี change identity)
  target    String?

  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime         @default(now())
  attemptCount Int      @default(0)
  /// relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// indexes (สำคัญต่อ cleanup + lookup)
  @@index([userId, type])
  @@index([expiresAt])
  @@index([tokenHash])
  @@index([type, expiresAt])       
  @@index([usedAt])               
  @@index([userId, type, usedAt])  
}

model SecurityEvent {
  id        String            @id @default(uuid())

  userId    String
  type      SecurityEventType

  ip        String?
  userAgent String?
  metadata  Json?

  createdAt DateTime          @default(now())

  /// relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// indexes (critical)
  @@index([userId, createdAt])
  @@index([type])
}

model UserIdentityHistory {
  id        String   @id @default(uuid())
  userId    String
  field     String   // email, phone, username
  oldValue  String?
  newValue  String?
  changedBy String   // USER | ADMIN | SYSTEM
  createdAt DateTime @default(now())
  adminId   String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([field])
}


